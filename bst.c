#include  <stdio.h>
#include  <time.h>

#define MAXNUMB 10  /* Maximum no. of numbers to be inserted into the
                       tree */

/* Following structure is used as node for the tree */
struct node {
	int             value;
	struct node *   left ;
	struct node *   right;
};

typedef struct node  *Nodeptr; /* Pointer to the node.*/

int num_table[MAXNUMB]; /* Array of integers to hold the random numbers
			   generated by generate_random.Also used later
			   for shuffling the numbers randomly and then
			   deleting from the tree.
			 */
int num_of_comparisons ; /* Number of comparisons while inserting. */

void generate_random()  /* Generates MAXNUMB random random numbers and places
			   in the array num_table */
{
	FILE  *fp;
	int number;
	int  i;

	fp = fopen("rand100.txt","w");
	srand( (unsigned int) time(NULL));  /* initialize the 
                                                random number
						  generator. */
	for (i=0;i<MAXNUMB;i++){
		number = rand();           /* generate a random integer */
		fprintf(fp,"%d\n",number); /* Store in file.*/
		num_table[i] = number;     /*Store in array.*/
	}
	fclose(fp);
}

/* getnode : allocate memory for node and return pointer to it */
Nodeptr  getnode(void)
{
	return  (Nodeptr) malloc(sizeof(struct node));
}

/* addtree :  add in_num to the tree */
Nodeptr  addtree(int in_num,Nodeptr thisptr)
{

	if (thisptr == NULL)
	{
		thisptr = getnode();
		thisptr->left = NULL;
		thisptr->right = NULL;
		thisptr->value = in_num;
		return thisptr;
	}
	else if (in_num < thisptr->value)
		thisptr->left = addtree(in_num,thisptr->left);
	else if (in_num >thisptr->value)
		thisptr->right = addtree(in_num,thisptr->right);
	return thisptr;
}

/* maketree : get numbers from array num_table and add to the tree */
Nodeptr maketree(void)
{
	int   number;
	int   i;
	Nodeptr root;

	root = NULL;
	for (i=0; i < MAXNUMB ; i++){
		number = num_table[i];
		printf("%d ",number);
		root = addtree(number,root);
	}
	printf(" \n");
	return root;
}

/*
treeprint : prints the tree in bracketed form recursively i.e.
			   (leftsubtree  node-label  righsubtree)
*/
void treeprint(Nodeptr thisnode)
{
	if (thisnode != NULL)
	{
		printf("(");
		treeprint(thisnode->left);
		printf("%d",thisnode->value);
		treeprint(thisnode->right);
		printf(")");
	}
        else printf(".");
}

/* swap : swaps two integers */
void swap(int *x,int *y)
{
	int tempint;

	tempint = *x;
	*x = *y;
	*y = tempint;
}

/* shuffle : shuffles the numbers in the num_table in random fashion */
void shuffle(int table[MAXNUMB])
{
	int i;

	for (i = 0; i < MAXNUMB; i++)
		swap(table + i, table + rand() % MAXNUMB);
		 /* Swap the element in each position
		    with an element in a random
		    location. */
}

/*
deletenode : deletes the node pointed to by pointer curptr which is one
of the child pointers of the parent node.
*/
void deletenode(Nodeptr *curptr)
{
	Nodeptr p;

	printf("in deletenode");
	if (*curptr != NULL)
	{
		if ((*curptr)->right == NULL)
		{
			p = *curptr;
			*curptr = (*curptr)->left;
		}
		else if ((*curptr)->left ==NULL)
		{
			p = *curptr;
			*curptr = (*curptr)->right;
		}
		else
		{
			p = (*curptr)->right;
			while (p->left != NULL)
				p = p->left;

			p->left = (*curptr)->left;
			p = *curptr;
			*curptr = (*curptr)->right;
		}
	}
	else printf("NULL deleted"); /* Bug! */
}

/*
searchnode : searches the node containing the number and returns a pointer
to its parent.In case of root pointer to root node is returned.
*/
Nodeptr searchnode(Nodeptr curptr,int number)
{
	Nodeptr tempptr = curptr;

	printf("In searchnode");
	while (curptr !=NULL)
	{
		if (curptr->value == number)
			return tempptr;
		else {
			tempptr = curptr;
			if (number < curptr->value)
				curptr = curptr->left;
			else
				curptr = curptr->right;
		}
	}
	return NULL; /* Number not found : (Bug?) */
}

/*
 deletetree : shuffles the elements in the array num_table and deletes them
from the tree one by one.
*/
void deletetree(Nodeptr root)
{
	int i;
	Nodeptr delptr; /* pointer returned by the function search node */

	shuffle(num_table); /* shuffle the array elements */
	for(i=0;i<MAXNUMB;i++)
	{
		printf("In deltr:%d",root->value);
		treeprint(root);  /* Print the tree. */
		printf("\ntprovr");
		printf("*%d*",num_table[i]);   /* Print the number to be deleted */
		if((delptr = searchnode(root,num_table[i])) == NULL)
		    /* Find the node to be deleted and see if NULL*/
		    printf("Error : Node not found");
		treeprint(delptr);
		if (delptr == root && root->value==num_table[i])/* node to be deleted*/
			deletenode(&root);                             /* is the root.      */
		else if (num_table[i] == delptr->left->value) /* delete left child node*/
			deletenode(&delptr->left);
		else if (num_table[i] == delptr->right->value)
			deletenode(&delptr->right);            /* delete right child node*/
		else printf("Error : number not found");
		printf("\n");
	}
	if (root!=NULL)
		printf("Error : tree still not empty\n"); /* Some bug somewhere.*/
}

/*****************************************************************************/
main()
{
	Nodeptr root;

	generate_random(); /* generate random numbers */
	root = maketree(); /* add all the numbers to tree */
	treeprint(root);   /* print resultant tree */
	printf(" \n");
	deletetree(root);  /* delete the elements in random order */
	return 0;
}
